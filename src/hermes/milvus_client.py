"""Milvus client for persisting embeddings.

This module provides a client for connecting to Milvus and persisting
text embeddings generated by Hermes.
"""

import logging
import time
from typing import Any, Optional

from logos_config import get_env_value

logger = logging.getLogger(__name__)

# Try importing Milvus library
try:
    from pymilvus import (
        Collection,
        CollectionSchema,
        DataType,
        FieldSchema,
        connections,
        utility,
    )

    MILVUS_AVAILABLE = True
except ImportError:
    MILVUS_AVAILABLE = False
    logger.warning("pymilvus not available. Install with: pip install pymilvus")


# Global connection state
_milvus_connected = False
_milvus_collection: Optional[Any] = None

# Lazy-loaded configuration - deferred until first use to avoid import-time env reads
_milvus_host: Optional[str] = None
_milvus_port: Optional[str] = None
_collection_name: Optional[str] = None
EMBEDDING_DIMENSION = 384  # all-MiniLM-L6-v2 dimension


def get_milvus_host() -> str:
    """Get Milvus host, reading from env on first call."""
    global _milvus_host
    if _milvus_host is None:
        _milvus_host = get_env_value("MILVUS_HOST", default="localhost") or "localhost"
    return _milvus_host


def get_milvus_port() -> str:
    """Get Milvus port, reading from env on first call."""
    global _milvus_port
    if _milvus_port is None:
        _milvus_port = get_env_value("MILVUS_PORT", default="17530") or "17530"
    return _milvus_port


def get_collection_name() -> str:
    """Get collection name, reading from env on first call."""
    global _collection_name
    if _collection_name is None:
        _collection_name = (
            get_env_value("MILVUS_COLLECTION_NAME", default="hermes_embeddings")
            or "hermes_embeddings"
        )
    return _collection_name


def is_milvus_available() -> bool:
    """Check if Milvus is available and configured."""
    return MILVUS_AVAILABLE


def disconnect_milvus() -> None:
    """Disconnect from Milvus server and reset global state.

    This should be called at application shutdown to cleanly
    release the connection and reset state for potential restart.
    """
    global _milvus_connected, _milvus_collection

    if not MILVUS_AVAILABLE:
        return

    try:
        connections.disconnect(alias="default")
        logger.info("Disconnected from Milvus")
    except Exception as e:
        logger.warning(f"Error disconnecting from Milvus: {str(e)}")
    finally:
        _milvus_connected = False
        _milvus_collection = None


def connect_milvus() -> bool:
    """Connect to Milvus server.

    Returns:
        True if connection successful, False otherwise
    """
    if not MILVUS_AVAILABLE:
        logger.warning("pymilvus library not available")
        return False

    global _milvus_connected
    if _milvus_connected:
        return True

    try:
        host = get_milvus_host()
        port = get_milvus_port()
        connections.connect(
            alias="default",
            host=host,
            port=port,
            timeout=5,
        )
        _milvus_connected = True
        logger.info(f"Connected to Milvus at {host}:{port}")
        return True
    except Exception as e:
        logger.warning(f"Failed to connect to Milvus: {str(e)}")
        _milvus_connected = False
        return False


def ensure_collection() -> Optional[Any]:
    """Ensure the embeddings collection exists with the correct schema.

    Returns:
        Collection object if successful, None otherwise
    """
    if not MILVUS_AVAILABLE or not _milvus_connected:
        return None

    global _milvus_collection

    try:
        collection_name = get_collection_name()
        # Check if collection already exists
        if utility.has_collection(collection_name):
            # Always get a fresh collection reference to avoid stale references
            # (e.g., if collection was dropped and recreated externally)
            _milvus_collection = Collection(name=collection_name)
            return _milvus_collection

        # Create new collection with schema from c-daly/logos#155
        logger.info(f"Creating Milvus collection: {collection_name}")

        fields = [
            FieldSchema(
                name="embedding_id",
                dtype=DataType.VARCHAR,
                is_primary=True,
                max_length=64,
            ),
            FieldSchema(
                name="embedding", dtype=DataType.FLOAT_VECTOR, dim=EMBEDDING_DIMENSION
            ),
            FieldSchema(name="model", dtype=DataType.VARCHAR, max_length=256),
            FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=65535),
            FieldSchema(name="timestamp", dtype=DataType.INT64),
        ]

        schema = CollectionSchema(
            fields=fields, description="Hermes text embeddings collection"
        )

        collection = Collection(name=collection_name, schema=schema)

        # Create index for vector field
        index_params = {
            "index_type": "IVF_FLAT",
            "metric_type": "L2",
            "params": {"nlist": 128},
        }
        collection.create_index(field_name="embedding", index_params=index_params)

        logger.info(f"Collection {collection_name} created successfully")
        _milvus_collection = collection
        return collection

    except Exception as e:
        logger.error(f"Failed to create/ensure collection: {str(e)}")
        return None


async def persist_embedding(
    embedding_id: str,
    embedding: list,
    model: str,
    text: str,
) -> bool:
    """Persist an embedding to Milvus.

    Args:
        embedding_id: Unique identifier for the embedding
        embedding: Vector embedding (list of floats)
        model: Model name used for embedding
        text: Original text that was embedded

    Returns:
        True if persistence successful, False otherwise
    """
    if not MILVUS_AVAILABLE or not _milvus_connected:
        logger.debug("Milvus not available, skipping persistence")
        return False

    try:
        collection = ensure_collection()
        if collection is None:
            logger.warning("Failed to get collection, skipping persistence")
            return False

        # Prepare entity data
        timestamp = int(time.time() * 1000)  # milliseconds
        entities = [
            [embedding_id],  # embedding_id
            [embedding],  # embedding
            [model],  # model
            [text],  # text
            [timestamp],  # timestamp
        ]

        # Insert into Milvus
        collection.insert(entities)
        collection.flush()

        logger.info(f"Persisted embedding {embedding_id} to Milvus")
        return True

    except Exception as e:
        logger.error(f"Failed to persist embedding to Milvus: {str(e)}")
        return False


def initialize_milvus() -> bool:
    """Initialize Milvus connection and collection.

    This should be called at application startup.

    Returns:
        True if initialization successful, False otherwise
    """
    if not MILVUS_AVAILABLE:
        logger.info("Milvus integration disabled (pymilvus not installed)")
        return False

    logger.info("Initializing Milvus integration...")

    # Try to connect
    if not connect_milvus():
        logger.warning("Milvus connection failed, persistence will be disabled")
        return False

    # Ensure collection exists
    collection = ensure_collection()
    if collection is None:
        logger.warning(
            "Failed to create/ensure collection, persistence will be disabled"
        )
        return False

    logger.info("Milvus integration initialized successfully")
    return True
